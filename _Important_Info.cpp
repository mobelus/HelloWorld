- выделить машину
- выделить салон
Разномасность фотографий:
-- сколько, по каким критериям, углы, ракурсы, порядок. Как их классифицировать / отбор по каким критериям.
  
- стоимость запчасти
- определить степень повреждения
- мин / средняя / тоталь - разбираются специалисты
- средние истории убытков

--- прогнозирование
--- поиск аномалий (мошенничество)
  - anti prod - огромные массивы данных. Распознавание плохих и хороших паттернов.
  - по нахождению плохих паттернов можно

DOWNLOAD AT HOME:
http://www.codeforge.com/read/44206/MainForm.cpp__html
http://www.cyberforum.ru/post3963198.html
http://read.pudn.com/downloads140/sourcecode/multimedia/streaming/602172/demo.cpp/MainForm.cpp__.htm





////////////////////////////////////////////////////////////////////////
РАСПОЗНАВАНИЕ ОБРАЗОВ:
ОБЯЗАТЕЛЬНО К ПРОЧТЕНИЮ
https://habrahabr.ru/post/208090/
Минимальная доступная теория:
http://ict.informika.ru/ft/005972/m08-204.pdf
http://evloevoleg.narod.ru/Neural/Par_4.pdf

Подходы к распознаванию различных объектов:
http://matlab.exponenta.ru/imageprocess/book3/14/imfeature.php

КТО МОЖЕТ ПОМОЧЬ:
http://forum.sources.ru/index.php?showtopic=318162
http://www.ampersant.ru/raspoznavanie_obrazov/

Библиотеки:1
1) OpenCV
- Распознавание образов с OpenCV: Контуры против Haartraining
  Установив среду я приступил, наконец, к созданию своих первых HelloWord`ов. 
  Советую пробежаться по OpenCV шаг за шагом - http://robocraft.ru/page/opencv/
  Я перепробовал массу англоязычных и русскоязычых статей и форумов. Этот сборник статей наиболее понятно описывает функционал библиотеки OpenCV. 
  В первых статьях этого мануала описывается довольно простой алгоритм захвата видео с web-камеры, http://robocraft.ru/blog/computervision/275.html
  а в кульминации этих статей я нашел, наконец, как выделять и сравнивать контуры.
http://www.pvsm.ru/algoritmy/30704

КОНТУРЫ - Нахождение, Выделение, Сравнение:
http://blog.vidikon.com/?cat=1 (with code)

- Распознавание образов для программистов с использованием библиотеки OpenCV -- Детектирование объектов с помощью особенностей в OpenCV: FREAK. Детектирование множества объектов.
http://recog.ru/blog/opencv/
http://recog.ru/blog/opencv/200.html (with code)

YOUTUBE:
Face recognition and training in opencv - https://www.youtube.com/watch?v=WfrHM24aFIE
Распознавание номеров авто - http://recog.ru/blog/applied/202.html
OpenCV 3 KNN Character Recognition C++ - https://www.youtube.com/watch?v=CK0OCeCN9zg

РАСПОЗНАВАНИЕ АВТО С НУЖНЫМИ ПРИЗНАКАМИ ДЛЯ НЕЙРОННОЙ СЕТИ - БЕЗ КОДА:
Car detection and counting
https://www.youtube.com/watch?v=TNgvUq4EaSc


GITHUB:
Распознавание номеров авто - OpenCV 3 License Plate Recognition C++ full source code
https://www.youtube.com/watch?v=euG7-o9oPKg
https://github.com/MicrocontrollersAndMore/OpenCV_3_License_Plate_Recognition_Cpp
Распознавание Автомобилей - OpenCV 3 Car Counting C++ full source code
https://www.youtube.com/watch?v=Y3ac5rFMNZ0
https://github.com/MicrocontrollersAndMore/OpenCV_3_Car_Counting_Cpp

COURSE.ZIP
Разработка приложения для распознавания графических образов.
http://www.zoonman.ru/projects/kw/




//
РАСПОЗНАВАНИЕ + НЕЙРОСЕТИ:
https://geektimes.ru/post/90867/
https://geektimes.ru/post/74326/
http://eblearn.sourceforge.net
https://www.codeproject.com/kb/library/neuralnetrecognition.aspx
http://yann.lecun.com/exdb/mnist/index.html


/////////////////////////////////////////////////////////////////////////////////////////
НЕЙРОННЫЕ СЕТИ:
СОВЕТЫ: https://geektimes.ru/post/211610/
http://masandilov.ru/ai/neural_networks
http://evloevoleg.narod.ru/Neural/Par_4.pdf

РАЗРАБОТКА И ТЕОРИЯ:
http://algolist.manual.ru/ai/neuro/index.php
ЛУЧШИЙ ПРИМЕР С ОБЪЯСНЕНИЕМ И КОДОМ НА СИ++
https://www.youtube.com/watch?v=KkwX7FkLfug

ВАРИАНТЫ НЕЙРОННЫХ СЕТЕЙ:
Многослойные ПЕРЦЕПТРОНЫ - http://forum.pascal.net.ru/index.php?showtopic=25644 (МЕТОДИЧКА с описанием +ошибка в формуле последний пост)
Нейронная сеть Коххана - 
Нейронная сеть Хопфилда 
  text recognition
  https://software.intel.com/ru-ru/blogs/2011/12/22/finereader-2 (with code)

СПИСОК БИБЛИОТЕК:
http://bookflow.ru/nejrosetevoe-programmnoe-obespechenie/
1) БиблиотекаCaffe
http://mechanoid.kiev.ua/ml-lenet.html
2) Библиотека FANN. Создание простой нейронной сети на C++
http://leenissen.dk/fann/wp/language-bindings/
http://1q5p6.blogspot.ru/2015/11/fann.html
Скачать ALGLIB
http://alglib.sources.ru/dataanalysis/neuralnetworks.php

ПРИМЕР:
http://www.codeproject.com/Articles/19323/Image-Recognition-with-Neural-Networks
https://software.intel.com/ru-ru/blogs/2011/12/22/finereader-2
http://netcode.ru/cpp/?skatID=105&artID=3994
// NEURALNET.ZIP

ПОСЛЕДНИЕ НОВОСТИ О НЕЙРОННЫХ СЕТЯХ:
https://tproger.ru/tag/neural-network/


NEURONETZE:
http://kubstu.ru/data/fdlist/FDD0445.pdf

ARTICLES:
http://www.ipol.im/pub/art/2015/137/article_lr.pdf
http://neuroph.sourceforge.net/image_recognition.html

Pattern Recognition and Image Processing in C++
http://www.springer.com/gp/book/9783528054915

Programms:
https://sourceforge.net/directory/os:windows/?q=image%20pattern%20recognition


GITHUB-LINKS:
https://github.com/zhangry868?tab=repositories

Capture Screen and save to AVI (Borland C++)
http://www.cyberforum.ru/cpp-builder/thread140321.html



Программа Recognition используя компонент TNeuralNetHopf , реализует нейронную сеть Хопфилда. 
  Программа решает задачу распознавания образов. На вход сети подается некий образ, возможно искаженный или 
  неполный и нейронная сеть восстанавливает образ, т.е. относит предъявляемый образ к одному из хранимых сетью образов, 
либо в случае неудачи, выдает новый образ, иногда называемый "химерой".
  
  

/////////////////////////////////////////////////////////////////////////////

ONLINE-BOOCKS:

/////////////////////////////////////////// RUSSIAN:
Джеффри РИХТЕР "Windows для профессионалов"
ПРОГРАММИРОВАНИЕ НА ЯЗЫКЕ СИ
Бьярн Страустрап. Введение в язык Си++
Хрестоматия по программированию на Си в Unix
Справочное руководство по C++
Visual C++ / FAQ Index

C++ в хадачах и примерах (Borland C++)

50 КНИГ ПО С++
http://www.ph4s.ru/bookprogramir_1.html  

BORLAND C++ TOOLS
http://www.cnpack.org/showlist.php?id=39&lang=en


/////////////////////////////////////////// DEUTSCH:
http://www.highscore.de/cpp/aufbau/

// SOME LINKS:
https://www.gulp.de/freiberufler/E05BEE62.html





C:\statji.txt
"семантический анализ применение"
"направления исследования сематического анализа"

https://toster.ru/q/31851
Достижимые цели у этой задачи сейчас такие: 
* автокаталог (поток новостей распихивать по темам)
* автореферат (из текста выбрать — или составить — то, что его вкратце опишет, и при поиске показать)
Недостижимая на сегодня цель — выделить сущности, устранить синтаксическую и семантическую неоднозначность, сохранить связи и отношения в базе знаний (пример: из текста этой статьи узнать о новой единице измерения и уметь переводить её в литры). То есть понять смысл текста так, как его понимает человек. 
Если про своё про практическое, то я участвовал недолго в этом проекте. Применял его (ох...) для авто-реврайта текстов с учётом контекста (чтоб в тексте про машины заменяла бы слово «oil» на «petroleum», но никак не на «flattery»).

http://www.derwhite.com/2012/09/02/pochti-ideya-programmy-pochti-dlya-semanticheskogo-analiza-teksta/
Вы можете связаться со мной по почте hello@derwhite.com или через skype podluzny. Мне интересны новые и нестандартные задачи, поэтому я с удовольствием с вами пообщаюсь по профессиональным вопросам.

http://www.apmath.spbu.ru/ru/info/tuzov/onapr.html
поиск документов в локальных и глобальных сетях,
сортировка и классификация документов,
автоматическое аннотирование и реферирование,
системы автоматического контроля,
вопросно-ответные системы,
диалоговые системы,
обучающие и обучающиеся системы,
модификация и пополнение баз знаний,
экспертные системы,
машинный перевод.

Семантический анализ  текстов с использованием  системы Texterra
//
Викификация является разновидностью за-
дачи разрешения лексической многозначности, в которой в качестве источ-
ника знаний выступают статьи Википедии.

/ Семантической паутины (Semantic web),

/ Семантический перевод

/ построение текстов по заданному смысловому заданию (машинный
перевод, вопросно-ответные системы, извлечение информации из текстов и др.);

/ Генерация текстов
Формирование контента на сайтах / форумах / и т.д.

/ Тезисный разбор текста
Совершенно верно. Средств (программ) совмещающих в себе текстовое представление и параллельное отображение в компактном виде основных ключевых мыслей (фраз) не знаю, но необходимость давно назрела. На первом этапе достаточно будет, что бы пользователь сам формировал структуру текста в в виде какой либо нотации (MindMap, ДРАКОН и т.д.). Как вариант для использования алгоритма обработки текста можно использовать метод Едигес А.П., приведенный в книге «Лабиринты мышления, или учеными не рождаются».

/ Обучение
Появилась интересная программа http://www.activelylearn.com/ , но она ориентирована на область образования.

/ ПОИСК ЗАПРОСОВ
Мы думаем про что-то такое для своего проекта — человек пишет в поиск, де, «трёхкомнатная вилла на Майорке в конце августа» — и ему хоп, показывает результаты поиска с точно заданными параметрами.

РЕКЛАМА / ПРЕДЛОЖЕНИЯ / МАРКЕТИНГ:
Очень насущная задача много для чего — это автоматическая классификация. Например, из длинного пространного описания гаечных ключей понять, что они бывают такие и такие, ключ номер 1 такой, а ключ номер три — другой.

БИРЖА:
вот мы делаем системы для создания технологических форсайтов (это что-то среднее между планами и прогнозами). Люди собирают т.н. сигналы — события, которые могут быть важными для отрасли, и на основе нескольких сигналов у них должны появляться идеи трендов. Сигналов много, поэтому хочется показывать пользователю небольшие группы сигналов, которые связаны между собой или как-либо похожи. Тут бы очень пригодился классификатор.
  
  
  
  
  
  
/////////////////////////////////////////////////////////////
// О ВИРТ. ФУНКЦИЯХ
/////////////////////////////////////////////////////////////
// http://www.cyberforum.ru/cpp-beginners/thread1391513.html#post7321173
// 17.03.2015, 23:25  [ТС]

    AA* pa; 
// Указателю на базовый класс присваиваем адрес ПРОИЗВОДНОГО класса:
    pa=&b;   
    pa->f();// виртуальный вызов f() из B
    pa->AA::f();// невиртуальный вызов f() из AA

/////////////////////////////////////////////////////////////
// РЕАЛИЗОВАТЬ СВОЙ  УМНЫЙ УКАЗАТЕЛЬ
/////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////
// РЕАЛИЗОВАТЬ СВОЙ  УМНЫЙ УКАЗАТЕЛЬ - UNIQUE_PTR
/////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////
// РЕАЛИЗОВАТЬ СВОЙ  УМНЫЙ УКАЗАТЕЛЬ - SHARED_PTR
/////////////////////////////////////////////////////////////
MY SHARED_PTR:
http://www.cyberforum.ru/cpp-beginners/thread943866.html

/////////////////////////////////////////////////////////////
// РЕАЛИЗОВАТЬ СВОЙ  LIST
/////////////////////////////////////////////////////////////

	http://www.cyberforum.ru/cpp-beginners/thread178335.html#post1039880

NEED LIST WITH A    NODE
struct node
{
	char some;
	int key;
};
	
/////////////////////////////////////////////////////////////
// РЕАЛИЗОВАТЬ СВОЙ  VECTOR
/////////////////////////////////////////////////////////////
	
	http://www.cyberforum.ru/cpp-beginners/thread178335.html#post1693182

/////////////////////////////////////////////////////////////
// РЕАЛИЗОВАТЬ СВОЙ  HASH TABLE
/////////////////////////////////////////////////////////////

http://www.programmersforum.ru/showthread.php?t=69994

const int maxn=10000;
struct node
{
	char znac[20];
	int key;
};

int kolcol;
int kolsl;
int ObTable;

node hashtable[maxn];



/////////////////////////////////////////////////////////////
// РЕАЛИЗОВАТЬ СВОЙ  MAP
/////////////////////////////////////////////////////////////

	
/////////////////////////////////////////////////////////////
// РЕАЛИЗОВАТЬ СВОЮ ФУНКЦИЮ  ATOI
/////////////////////////////////////////////////////////////

int atoi(char s[])
{
    int i, n;
    n = 0;
    for (i = 0; s[i] >= '0' && s[i] <= '9'; ++i)
		n = (n * 10) + (s[i] - '0');
    return n;
}

int atoi(char* s)
{
    int n = 0;
    while( *s >= '0' && *s <= '9' ) {
        n *= 10;
        n += *s++;
        n -= '0';
    }
    return n;
}

int my_atoi(const char*  src)
{
	int result = 0;
	int digit = 1;
	const int DIGIT_DIFFERENCE = 10;
	const char ZERO_SYMBOL = '0';
	for(int i = (strlen(str)-1); i >= 0; i--)
	{
		result = result + (digit * int(str[i]-ZERO_SYMBOL));
		digit = digit * DIGIT_DIFFERENCE;
	}
	return result;
	
	// NO delimiters 
	// NO trim string fuction for space-characters 
	// NO negative numbers / multiple minus symbols in string
	// NO check if there exist other symbols than numbers in string
}


#include <iostream>
#include <cstdlib>
using namespace std;
static const char MINUS = '-';
char* my_trimLeft(const char* src);
int my_atoi(const char*  src);
int main()
{
	cout << my_atoi("bjk vvh-)(-20856--fbhcfr f");
	cin.get();
	return 0;
}
// Implement the function, that transforms string into integer.
int my_atoi(const char*  src)
{
	bool isNegative = false;
	char* str = my_trimLeft(src);
	if(str == NULL)
	{
		return EXIT_FAILURE;			// input error, terminating
	}
	if(str[0] == MINUS)
	{
		isNegative = true;
		str++;
	}
	int result = 0;
	int digit = 1;
	const int DIGIT_DIFFERENCE = 10;
	const char ZERO_SYMBOL = '0';
	for(int i = (strlen(str)-1); i >= 0; i--)
	{
		result = result + (digit * int(str[i]-ZERO_SYMBOL));
		digit = digit * DIGIT_DIFFERENCE;
	}
	if(isNegative == false)
	{
		delete [] str;
		return result;
	}
	else
	{
		str--;
		delete [] str;
		return -result;
	}
}
char* my_trimLeft(const char* src)
{
	if(strlen(src) == 0)	// there's no string
	{
		return NULL;
	}
	char* resultStr = new char[strlen(src)];
	int srcIndex = 0;
	int resultIndex = 0;
	while(	(0 == isdigit(src[srcIndex]))
		&&
			(srcIndex < strlen(src))
		)
	{
		if ((src[srcIndex] == MINUS) && (0 != isdigit(src[srcIndex+1])))
		{
			resultStr[resultIndex] = MINUS;
			resultIndex++;
		}
		srcIndex++;
	}
	// now srcIndex indexes the first numeric in the string
	while(	(0 != isdigit(src[srcIndex]))
		&&
			(srcIndex < strlen(src))
		)
	{
		resultStr[resultIndex] = src[srcIndex];
		resultIndex++;
		srcIndex++;
	}
	resultStr[resultIndex] = '\0';
	if(resultIndex == 0)	// no numerics in the string
	{
		return NULL;
	}
	return resultStr;
}


int my_atoi(const char*  src)
{
  int result = 0;
  const char*  tmp_src;
  tmp_src = src;

  if (*tmp_src=='-')
	  tmp_src++;
  for(;strlen(tmp_src)>0; result = (result*10) + ((char)*(tmp_src++)-'0'));
  result *= (*src == '-') ? -1 : 1;
  
  return result;
}


#include <iostream.h>
#include <string.h>
#include <ctype.h>

char *itoa (int n, char *s)
{
 char *t=s;
 int z=0;
 
 if (n<0) { z=1; n = -n; }
 do *s++ = n%10 + '0';
 while (n/=10);
 if (z) *s++ = '-';
 *s = '\0';
 
 return strrev(t);
}

int atoi (char *s)
{
 int z=0, n=0;
 while(isspace(*s)) s++;
 
 if (*s=='-')
 { z=1; s++; }
 else if (*s=='+')
	 s++;
 while (isdigit(*s))
	 n = (10*n) + *s++ - '0';
 return (z?-n:n);
}

void main ()
{
 int n=-31289;
 char buf[80];
 cout << "\nitoa=" << itoa (n,buf);
 cout << "\natoi=" << atoi (buf);
 cin.get();
}

/////////////////////////////////////////////////////////////
// РАЗВЕРНУТЬ СТРОКУ
/////////////////////////////////////////////////////////////

// STL РЕШЕНИЕ
#include <iostream>
#include<string>
#include <algorithm>

std::string goodbyeWorld="Hello World";
std::reverse(goodbyeWorld.begin(), goodbyeWorld.end());
std::cout<<goodbyeWorld<<std::endl;

// ШАБЛОННОЕ РЕШЕНИЕ
#include <iostream>
#include <algorithm>

template<typename T> void t_reverse(T* a, T* b) 
{
    T t;
    for(b -= 1; a < b; ++a, --b) {
        t  = *a;
       *a = *b;
       *b = t;
   }
}


int main()
{
   char s[] = "123";
   puts(s);  // исходная строка
   t_reverse(s, s + strlen(s));
   puts(s);  // вывод реверс-строки
	
   double arr[] = { 10.99, 34.66, 3.14567, 1.7 };
   int size  = sizeof(arr)/sizeof(arr[0]);

   // выведем исходный массив
   std::copy(arr, arr + size, std::ostream_iterator<double>(std::cout, "\t"));
   t_reverse(arr, arr + size);
   std::cout << std::endl;
   // выведем реверс массив
   std::copy(arr, arr + size, std::ostream_iterator<double>(std::cout, "\t"));
   return 0;
}



// РЕКУРСИВНОЕ РЕШЕНИЕ
#include <iostream.h>
 
void RevStr(char* S,int l)
{
    char c;
    if (l > 1)
    {
      c=S[0];
      S[0]=S[l-1];
      S[l-1]=c;
      RevStr(S+1,l-2);
    }             
}       
 
int main(int argc, char* argv[])
{
    char S[12]="Test of pen";
    RevStr(S,11);
    cout << S << endl;
    return 0;
}


// РЕШЕНИЕ НА УКАЗАТЕЛЯХ
char* strrev(char* str)
{
    char* left = str;
    char* rigth = str;
    while (*str++)
		str -= 2;
    while (left < str)
    {
        char c = *left;
        *left++ = *str;
        *str-- = c;
    }
    return rigth;
}

int main()
{
    char x[100] = {"String reverse"};
    std::cout << strrev(x);
    return 0;
}

// ЧЕРЕЗ ПОЛОВИНУ С ЛЕВОЙ СТОРОНЫ
{
   char str[] = "12345678";
   const size_t strLen = sizeof(str);
   for (size_t i = (strLen/2)-1; i--;)
      swap(str[i], str[strLen-i-2]);
   cout << str << endl;
}

// ЧЕРЕЗ ПОЛОВИНУ С ПРАВОЙ СТОРОНЫ
  l = strlen(s);
  for (i = 0; i < l/2; i++)
  {
     s[l+1] = s[i];
     s[i] = s[l-i];
     s[l-i] = s[l+1];
  } 
  s[l+1]=0;

  
